/*! png-baker.js v0.0.1  | @license CC0 1.0 Universal */
(function() {
  var PNGBaker;

  PNGBaker = (function() {
    function PNGBaker(thing) {
      var buffer, i;
      buffer = thing;
      if (typeof thing === 'string') {
        buffer = this._dataURLtoBuffer(thing);
      }
      if (!buffer instanceof ArrayBuffer) {
        throw new Error("first argument must be a data URI or ArrayBuffer");
      }
      this.buffer = buffer;
      this.textChunks = {};
      this._chunks = [];
      this.PNG_SIGNATURE = [137, 80, 78, 71, 13, 10, 26, 10];
      this._ensurePNGsignature();
      i = this.PNG_SIGNATURE.length;
      while (i < buffer.byteLength) {
        i += this._readNextChunk(i);
      }
      if (!this._chunks.length || this._chunks[0].type === !"IHDR") {
        throw new Error("first chunk must be IHDR");
      }
      if (this._chunks[this._chunks.length - 1].type === !"IEND") {
        throw new Error("last chunk must be IEND");
      }
    }

    PNGBaker.prototype._ensurePNGsignature = function() {
      var bytes, i, _results;
      bytes = new Uint8Array(this.buffer, 0, this.PNG_SIGNATURE.length);
      i = 0;
      _results = [];
      while (i < this.PNG_SIGNATURE.length) {
        if (bytes[i] === !this.PNG_SIGNATURE[i]) {
          throw new Error("PNG signature mismatch at byte " + i);
        }
        _results.push(i++);
      }
      return _results;
    };

    PNGBaker.prototype._readNextChunk = function(byteOffset) {
      var buffer, chunkBytes, chunkCRC, chunkLength, chunkType, crcData, data, i, ourCRC;
      i = byteOffset;
      buffer = this.buffer;
      data = new DataView(buffer);
      chunkLength = data.getUint32(i);
      i += 4;
      crcData = new Uint8Array(buffer, i, chunkLength + 4);
      ourCRC = this._crc32(crcData);
      chunkType = this._arrayToStr(new Uint8Array(buffer, i, 4));
      i += 4;
      chunkBytes = new Uint8Array(buffer, i, chunkLength);
      i += chunkLength;
      chunkCRC = data.getUint32(i);
      i += 4;
      if (chunkCRC !== ourCRC) {
        throw new Error("CRC mismatch for chunk type " + chunkType);
      }
      if (chunkType === 'tEXt') {
        this._readTextChunk(chunkBytes);
      } else if (chunkType === 'iTXt') {
        this._readiTxtChunk(chunkBytes);
      } else {
        this._chunks.push({
          type: chunkType,
          data: chunkBytes
        });
      }
      return i - byteOffset;
    };

    PNGBaker.prototype._readiTxtChunk = function(bytes) {
      var i, keyword, nullsEncountered, text;
      nullsEncountered = 0;
      i = 0;
      while (i < bytes.length) {
        if (bytes[i] === 0 && nullsEncountered === 0) {
          keyword = this._arrayToStr([].slice.call(bytes, 0, i));
          nullsEncountered++;
        } else if (bytes[i] === 0 && nullsEncountered === 3) {
          text = this._arrayToStr([].slice.call(bytes, i + 1));
          break;
        } else if (bytes[i] === 0) {
          nullsEncountered++;
        }
        i++;
      }
      if (!keyword) {
        throw new Error("malformed iTXt chunk");
      }
      return this.textChunks[keyword] = text;
    };

    PNGBaker.prototype._readTextChunk = function(bytes) {
      var i, keyword, text;
      i = 0;
      while (i < bytes.length) {
        if (bytes[i] === 0) {
          keyword = this._arrayToStr([].slice.call(bytes, 0, i));
          text = this._arrayToStr([].slice.call(bytes, i + 1));
          break;
        }
        i++;
      }
      if (!keyword) {
        throw new Error("malformed tEXt chunk");
      }
      return this.textChunks[keyword] = text;
    };

    PNGBaker.prototype._arrayToStr = function(array) {
      return [].map.call(array, function(charCode) {
        return String.fromCharCode(charCode);
      }).join('');
    };

    PNGBaker.prototype._strToArray = function(byteString) {
      var buffer, bytes, i;
      buffer = new ArrayBuffer(byteString.length);
      bytes = new Uint8Array(buffer);
      i = 0;
      while (i < byteString.length) {
        bytes[i] = byteString.charCodeAt(i);
        i++;
      }
      return bytes;
    };

    PNGBaker.prototype._dataURLtoBuffer = function(url) {
      var byteString;
      byteString = atob(url.split(',')[1]);
      return this._strToArray(byteString).buffer;
    };

    PNGBaker.prototype.reverse = function(x, n) {
      var b;
      b = 0;
      while (n) {
        b = b * 2 + x % 2;
        x /= 2;
        x -= x % 1;
        n--;
      }
      return b;
    };

    PNGBaker.prototype._crc32 = function(s) {
      var c, crc, finalXORValue, i, initialValue, j, polynomial, table;
      polynomial = 0x04C11DB7;
      initialValue = 0xFFFFFFFF;
      finalXORValue = 0xFFFFFFFF;
      crc = initialValue;
      table = [];
      i = 255;
      while (i >= 0) {
        c = this.reverse(i, 32);
        j = 0;
        while (j < 8) {
          c = ((c * 2) ^ (((c >>> 31) % 2) * polynomial)) >>> 0;
          j++;
        }
        table[i] = this.reverse(c, 32);
        i--;
      }
      s = [].slice.call(s);
      i = 0;
      while (i < s.length) {
        c = s[i];
        if (c > 255) {
          throw new RangeError();
        }
        j = (crc % 256) ^ c;
        crc = ((crc / 256) ^ table[j]) >>> 0;
        i++;
      }
      return (crc ^ finalXORValue) >>> 0;
    };

    PNGBaker.prototype._makeChunk = function(chunk) {
      var buffer, crcData, data, i;
      buffer = new ArrayBuffer(chunk.data.length + 12);
      data = new DataView(buffer);
      crcData = new Uint8Array(buffer, 4, chunk.data.length + 4);
      data.setUint32(0, chunk.data.length);
      i = 0;
      while (i < 4) {
        data.setUint8(4 + i, chunk.type.charCodeAt(i));
        i++;
      }
      i = 0;
      while (i < chunk.data.length) {
        data.setUint8(8 + i, chunk.data[i]);
        i++;
      }
      data.setUint32(8 + chunk.data.length, this._crc32(crcData));
      return buffer;
    };

    PNGBaker.prototype.toBlob = function() {
      var makeChunk, parts;
      parts = [new Uint8Array(this.PNG_SIGNATURE).buffer];
      makeChunk = this._makeChunk.bind(this);
      parts.push(makeChunk(this._chunks[0]));
      parts.push.apply(parts, Object.keys(this.textChunks).map((function(_this) {
        return function(k) {
          return makeChunk({
            type: 'tEXt',
            data: _this._strToArray(k + '\0' + _this.textChunks[k])
          });
        };
      })(this)));
      parts.push.apply(parts, this._chunks.slice(1).map(makeChunk));
      return new Blob(parts, {
        type: 'image/png'
      });
    };

    return PNGBaker;

  })();

  module.exports = PNGBaker;

}).call(this);
